#### 优化
> 首先，题目并不关心边长为1,2,...,k的各有多少个，并且我们知道，以(i, j)为右下角边长为k的正方形全为1的话，那么以(i, j)为右下角边长分别为1,2,...,k - 1的正方形区域一定是全为1，如下图：

![](http://qnfile.echatsoft.com/bc0801c2-eb68-4dc5-946a-ad4bfe0bb233)

> 上图中，如果红色区域是边长为3的全1正方形区域，那么它一定包含了一个边长为2和边长为1的全1正方形区域。所以，我们只需记录以(i, j)为右下角的区域包含的最大全1正方形边长即可，这个最大边长也即以(i , j)为右下角的全1正方形的个数.  
> 那么基于此，我们就可以将原始的dp降一维度，设dp[i][j]表示以(i, j)为右下角的最大全1正方形区域的边长，则有如下状态转移方程：

<pre>
dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
</pre>



